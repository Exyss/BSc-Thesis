
\chapter{Parity in black-box \textsf{TFNP}} \label{chap:parity-tfnp}

\section{Parity decision trees}

The concept of parity is extensively studied in computer science. In our case, we are interested in exploring parity through the lens of \textit{linear forms modulo 2}, i.e. linear combinations defined on $n$ variables over the algebraic field $\F_2$. In this field, each term can either be a 0 or a 1, with the defining characteristic that $1+1 = 0$.

\begin{definition}
 Given $n$ variables $x_1, \ldots, x_n$, we define a linear form as a linear combination over $\F_2$. In general, a linear form can be expressed as $\sum\limits_{i = 1}^n \alpha_i x_i$, where $\alpha_1, \ldots, \alpha_n \in \F_2$
\end{definition}

Intuitively, each sum in a linear form is nothing more than an application of the \textbf{XOR operator}: the linear form $x_1 + x_2$ is equal to 1 if and only if $x_1$ is \textit{different} from $x_2$ (i.e. if $x_1 = 1$ and $x_2 = 0$ or if $x_1 = 0$ and $x_2 = 1$). Additionally, in $\F_2$ the concepts of addition and subtraction are equivalent: since $1+1 = 0$, we easily get that $1 = -1$. Through these properties, parity can be used to determine if two or more objects are equal or not. For example, consider the following system of linear forms:
\[\left \{ \begin{array}{l}
 x_1 + x_2 + x_3 = 1 \\
 x_1 + x_2 + x_4 = 1 \\
 x_1 + x_3 = 1
\end{array} \right .\]

By simplifying the linear system we get that:
\[\left \{ \begin{array}{l}
 x_1 + x_2 + x_3 = 1 \\
 x_1 + x_2 + x_4 = 1 \\
 x_1 + x_3 = 1
\end{array} \right . \longrightarrow
\left \{ \begin{array}{l}
 x_2 = 1\\
 x_1 + 1 + x_4 = 1 \\
 x_1 + x_3 = 1
\end{array} \right . \longrightarrow
\left \{ \begin{array}{l}
 x_2 = 1\\
 x_1 = x_4 \\
 x_1 = 1+x_3
\end{array} \right .\]

which tells us that $x_2 = 1$ and $x_1 = x_4 \neq x_3$ must hold.

\newpage

But what happens if we apply the concept of parity in decision trees? What if, instead of querying variables to know their value, we ask the parity of a set of values by querying linear forms? This idea gives rise to the extended model of \textbf{parity decision trees}.

Instead of being labeled by single variables, the nodes of a parity decision tree (PDT for short) are labeled by a linear form $f$. Each node has two outgoing edges, one labeled by $f = 0$ and the other by $f = 1$. Every path from the root of the PDT to one of its nodes defines a system of linear forms given by all the labels of the edges on the path. In general, given the PDT $T$ and a node $v$, we denote this system with $\Phi_v^T$. Given an assignment $\alpha(x_1, \ldots, x_n)$, the output of a PDT is dictated by the parity queries made by each node.

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[ellipse, draw] (1)[] {$x_1+x_2+x_3$};

        \node[ellipse, draw] (2) [below left of=1, xshift=-50, ]{$x_1+x_2$};
        \node[ellipse, draw] (3) [below right of=1, xshift=50, ]{$x_1$};

        \node[ellipse, draw] (4) [below left of=2, xshift=-10, ]{$x_2+x_3$};
        \node[ellipse, draw] (5) [below right of=2, xshift=10, ]{$x_2$};
        \node[ellipse, draw] (6) [below left of=3, ]{$x_2$};
        \node[rectangle, draw] (7) [below right of=3]{$o_7$};

        \node[rectangle, draw] (8) [below left of=4, xshift=10, yshift=-10]{$o_1$};
        \node[rectangle, draw] (9) [below right of=4, xshift=-10, yshift=-10]{$o_2$};
        \node[rectangle, draw] (10) [below left of=5, xshift=10, yshift=-10]{$o_3$};
        \node[rectangle, draw] (11) [below right of=5, xshift=-10, yshift=-10]{$o_4$};
        \node[rectangle, draw] (12) [below left of=6, xshift=10, yshift=-10]{$o_5$};
        \node[rectangle, draw] (13) [below right of=6, xshift=-10, yshift=-10]{$o_6$};

        \path[every node/.style={font=\sffamily\small}]
 (1) edge[swap, color=Green]  node{0} (2)
 (1) edge node{1}(3)

 (2) edge[swap]  node{0} (4)
 (2) edge[color=Green]  node{1}(5)

 (3) edge[swap]  node{0} (6)
 (3) edge  node{1}(7)
                        
 (4) edge[swap]  node{0} (8)
 (4) edge  node{1}(9)

 (5) edge[swap]  node{0} (10)
 (5) edge[color=Green]  node{1}(11)

 (6) edge[swap]  node{0} (12)
 (6) edge  node{1}(13)
 ;
    \end{tikzpicture}

    \caption{An example of a parity decision tree of size 13 and depth 3.}
\end{figure}

In the above example, the green path defines the following system of linear forms:
\[\left \{ \begin{array}{l}
 x_1 + x_2 + x_3 = 0 \\
 x_1 + x_2 = 1 \\
 x_2 = 1
\end{array}\right .\]

which once simplified corresponds to the assignment $x_0 = 0, x_2 = 1, x_3 = 1$. We define the class $\mathsf{FP}^{pdt}$ as the set of $\mathsf{TFNP}^{dt}$ problems that are efficiently solvable by a PDT, where the complexity measures are defined as in normal decision trees.

\begin{definition}
 We define $\mathsf{FP}^{pdt}$ as the set of query search problems $R = (R_n)_{n \in \N}$ for which there exists a polylogarithmic depth PDT $T_n$ such that $T_n(x) = y$ if and only if $(x,y) \in R_n$.
\end{definition}

It's easy to see that $\mathsf{FP}^{dt} \subseteq \mathsf{FP}^{pdt}$ since any decision tree is just a PDT with all the queries defined only on one variable. Any PDT can be converted into a normal decision tree simply by \curlyquotes{splitting} each linear query. Given a node $v$ labeled with the linear form $f + x_i$, let $u$ and $w$ be the children of $v$ respectively given by $f + x_i = 0$ and $f+x_i = 1$. Let $T_u$ and $T_w$ be the two subtrees with root $u$ and $w$.

\newpage

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[ellipse, draw] (1)[] {$f + x_i$};

        \node[circle, draw] (2) [below left of=1, xshift=-50, ]{};
        \node[circle, draw] (3) [below right of=1, xshift=50, ]{};

        \node[] (2a) [below left of=2, yshift=-40]{};
        \node[] (2b) [below right of=2, yshift=-40]{};
        \node[] (2c) [below of=2]{$T_u$};

        \node[] (3a) [below left of=3, yshift=-40]{};
        \node[] (3b) [below right of=3, yshift=-40]{};
        \node[] (3c) [below of=3]{$T_w$};

        \path[every node/.style={font=\sffamily\small}]
 (1) edge[swap]  node{0} (2)
 (1) edge node{1}(3)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (2) edge (2a.center)
 (2) edge (2b.center)
 (2a.center) edge (2b.center)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (3) edge (3a.center)
 (3) edge (3b.center)
 (3a.center) edge (3b.center)
 ;
    \end{tikzpicture}

    \caption{The initial subtree of a parity decision tree.}
\end{figure}

We replace $v$ with the node $v'$ labeled with the linear form $x_i$ and introduce two new nodes $u', w'$ such that $u'$ is the child of $v'$ when $x_i = 0$ and $w'$ is the child of $v'$ when $x_i = 1$. We label $u'$ with the linear form $f$ and let a copy of $T_u$ be the children of $u'$ when $f = 0$, while a copy of $T_w$ is the children of $u'$ when $f = 1$. Symmetrically, we label $w'$ with the linear form $f$ and let a copy of $T_w$ be the children of $w'$ when $f = 0$, while a copy of $T_u$ is the children of $w'$ when $f = 1$. 

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[circle, draw] (1)[] {$x_i$};

        \node[circle, draw] (2) [below left of=1, xshift=-50, ]{$f$};
        \node[circle, draw] (3) [below right of=1, xshift=50, ]{$f$};

        \node[circle, draw] (2x) [below left of=2, xshift=-5]{};
        \node[circle, draw] (2y) [below right of=2, xshift=5]{};

        \node[circle, draw] (3x) [below left of=3, xshift=-5]{};
        \node[circle, draw] (3y) [below right of=3, xshift=5]{};

        \node[] (2a) [below left of=2x, yshift=-40]{};
        \node[] (2b) [below right of=2x, yshift=-40]{};
        \node[] (2c) [below of=2x]{$T_u$};

        \node[] (3a) [below left of=2y, yshift=-40]{};
        \node[] (3b) [below right of=2y, yshift=-40]{};
        \node[] (3c) [below of=2y]{$T_w$};

        \node[] (4a) [below left of=3x, yshift=-40]{};
        \node[] (4b) [below right of=3x, yshift=-40]{};
        \node[] (4c) [below of=3x]{$T_w$};

        \node[] (5a) [below left of=3y, yshift=-40]{};
        \node[] (5b) [below right of=3y, yshift=-40]{};
        \node[] (5c) [below of=3y]{$T_u$};

        \path[every node/.style={font=\sffamily\small}]
 (1) edge[swap]  node{0} (2)
 (1) edge node{1}(3)

 (2) edge[swap]  node{0} (2x)
 (2) edge node{1}(2y)

 (3) edge[swap]  node{0} (3x)
 (3) edge node{1}(3y)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (2x) edge (2a.center)
 (2x) edge (2b.center)
 (2a.center) edge (2b.center)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (2y) edge (3a.center)
 (2y) edge (3b.center)
 (3a.center) edge (3b.center)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (3x) edge (4a.center)
 (3x) edge (4b.center)
 (4a.center) edge (4b.center)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (3y) edge (5a.center)
 (3y) edge (5b.center)
 (5a.center) edge (5b.center)
 ;
    \end{tikzpicture}

    \caption{The subtree after the splitting process.}
\end{figure}

By repeating this process until all queries are defined on a single variable, we obtain a decision tree equivalent to the original PDT. This final decision tree has exponential size and polynomial depth, which \textit{may not} be the smallest possible decision tree that solves the search problem solved by the initial PDT. However, we can easily prove that parity decision trees are indeed much stronger than decision trees.

\begin{theorem}
    \label{fp_pdt_not_inside_fp_dt}
    $\mathsf{FP}^{dt} \subsetneq \mathsf{FP}^{pdt}$
\end{theorem}

\begin{proof}
 Any decision tree is also a parity decision tree, thus we trivially get that $\mathsf{FP}^{dt} \subseteq \mathsf{FP}^{pdt}$. Let $\mathrm{PARITY}$ be the \textit{$n$-bit parity search problem}, i.e. the problem of determining the parity of $n$ variables for a given assignment $\alpha$. This problem can be solved by a PDT of size and depth $O(1)$ by making a single query $x_1 + \ldots + x_n$, concluding that $\mathrm{PARITY} \in \mathsf{FP}^{dt}$.
    
    \begin{claim}
 Any decision tree solving $\mathrm{PARITY}$ on $n$ variables has depth $\Omega(n)$.
    \end{claim}

    \begin{proof}[Proof of the claim.]
 Suppose that $\mathrm{PARITY}$ on $n$ variables can be solved by a decision tree $T$ with depth less than $n$. We use an adversarial argument: we think of an execution
 of $T$, where some adversary answers each query of $T$ on the value of every input bit. The adversary can respond with $x_i = 0$ on all the first $n-1$ bits. Until the last bit $x_n$ is revealed, the tree has no way of determining the final output since it can either be 0 or 1 until the value of $x_n$ is revealed, concluding that it requires at least another query.
    \end{proof}
    
 By definition, $\mathsf{FP}^{dt}$ contains all the problems with a decision tree of polylogarithmic depth. Since $\mathrm{PARITY}$ requires a decision tree with depth $\Theta(n)$, we get that $\mathrm{PARITY} \notin \mathsf{FP}^{dt}$.
\end{proof}

Since a system of linear forms can have multiple solutions, many assignments could be mapped to the same output. However, some systems could also be unsatisfiable, meaning that the node is unreachable by any assignment. When this happens we say that the node is \textbf{degenerate}.

Like normal decision trees, PDTs can be used to solve the false clause search problem associated with any unsatisfiable CNF. A parity decision tree for a CNF formula $F$ is a PDT defined on the same variables of $F$ where for each leaf $v$ one of the following conditions holds:
\begin{enumerate}[itemsep=0em]
    \item The leaf is \textit{degenerate}
    \item The leaf \textit{refutes} a clause $C$ of $F$, meaning that the system $\Phi_v^T$ is satisfiable and every one of its solutions falsifies $C$
    \item The leaf \textit{satisfies} a clause $C$ of $F$, meaning that the system $\Phi_v^T$ has only one solution and it also satisfies $C$
\end{enumerate}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[ellipse, draw] (1)[] {$x + y$};

        \node[ellipse, draw] (2) [below left of=1, xshift=-20, ]{$x$};
        \node[ellipse, draw] (3) [below right of=1, xshift=20, ]{$x$};

        \node[rectangle, draw] (4) [below left of=2, xshift=10, yshift=-10]{$x \lor y$};
        \node[rectangle, draw] (5) [below right of=2, xshift=-10, yshift=-10]{$\lnot x \lor \lnot y$};
        \node[rectangle, draw] (6) [below left of=3, xshift=10, yshift=-10]{$x \lor \lnot y$};
        \node[rectangle, draw] (7) [below right of=3, xshift=-10, yshift=-10]{$\lnot x \lor y$};

        \path[every node/.style={font=\sffamily\small}]
 (1) edge[swap]  node{0} (2)
 (1) edge node{1}(3)

 (2) edge[swap]  node{0} (4)
 (2) edge[]  node{1}(5)

 (3) edge[swap]  node{0} (6)
 (3) edge  node{1}(7)
                        
 ;
    \end{tikzpicture}

    \caption{A parity decision tree for $(x \lor y) \land (\lnot x \lor \lnot y) \land (\lnot x \lor y) \land (x \lor \lnot y)$.}
\end{figure}

We observe that if a node doesn't meet any of the previous conditions then it cannot be a leaf node. Moreover, we also observe that the system associated with the root of any PDT is always satisfiable due to it containing no linear forms. Since we are interested in studying PDTs for refusing unsatisfiable CNF formulas, the third case will never be true for any leaf. However, we still need a way to exclude the first case since an unsatisfiable system cannot be associated with any assignment. Luckily, each degenerate PDT can be conveniently converted into a non-degenerate one through a very simple process \cite{res_lin_2}.

\begin{proposition}
    \label{degenerate}
 Let $F$ be an unsatisfiable CNF formula. If $S_F$ can be solved with a degenerate PDT of size $s$ and depth $d$, it can also be solved with a non-degenerate PDT of size at most $s$ and depth at most $d$.
\end{proposition}

\begin{proof}
    
 Let $T$ be a degenerate PDT of size $s$ and depth $d$ that solves $S_F$. Let $U$ be the set of degenerate nodes of $T$. Notice that since $\Phi_r^T$ is empty, thus always satisfiable, we know that $r \notin U$. Consider the node $u \in U$ with the minimal distance from the root $r$. Since $u$ is not the root of $T$, there must be two vertices $p$ and $s$ such that $p$ is the parent of $u$ and $s$ is the sibling of $u$.

 We notice that $\Phi_s^T$ must be satisfiable: if we assume that this is not true then both $\Phi_s^T$ and $\Phi_u^T$ would be unsatisfiable, which can be true only if $\Phi_p^T$ is also unsatisfiable, but we chose $w$ as the node in $U$ with minimal distance. Since $\Phi_s^T$ is satisfiable, the label $f = \alpha$ on the edge $(p,s)$ must be already implied $\Phi_p^T$, meaning that each assignment that satisfies $\Phi_p^T$ also satisfies $\Phi_s^T$.

 We construct a new PDT $T'$ by removing the subtree $T_u$ with root $u$ from the initial PDT $T$ and by contracting the edge $(p,s)$, merging the two nodes $p$ and $s$ into a single node $v$. In other words, the subtree $T_u$ gets removed and the children of $s$ become the new children of $p$. Each assignment that satisfies $\Phi_p^T$ also satisfies $\Phi_s^{T'}$, concluding that $T'$ also solves $S_F$. By repeating the process until $U$ is empty, we get a non-degenerate PDT that solves $S_F$ of size at most $s$ and depth at most $d$.
\end{proof}

\section{Linear Resolution over $\F_2$}

Once we have defined the class $\mathsf{FP}^{pdt}$, we are interested in finding a proof system that characterizes it. Consider a system $\Phi$ of linear forms defined on $\F_2$. This system can be viewed as the conjunction of the linear forms that it describes:
\[\left \{ \begin{array}{c}
 f_1 = \alpha_1 \\
 f_2 = \alpha_2 \\
    \vdots \\
 f_k = \alpha_k
\end{array}\right . \iff (f_1 = \alpha_1) \land (f_2 = \alpha_2) \land \ldots \land (f_k = \alpha_k)\]

\noindent
We can rewrite these conjunctions as a negation of a disjunction:
\[\bigwedge_{i = 1}^k (f_i = \alpha_i) \iff \lnot \bigvee_{i = 1}^k \lnot (f_i = \alpha_i) \iff \lnot \bigvee_{i = 1}^k (f_i = 1 + \alpha_i)\]

\noindent
which implies that the negation of the system is equivalent to a set of disjunctions:
\[\lnot \bigwedge_{i = 0}^k (f_1 = \alpha_1) \iff \bigvee_{i = 0}^k (f_1 = 1 + \alpha_1)\]

\noindent
We define such a set of disjunctions as a \textbf{linear clause}. More generally, a \textit{linear CNF formula} over $\F_q$ is a conjunction of linear clauses defined on $\F_q$.

\begin{definition}
 A linear CNF formula is a conjunction of $m$ disjunctions of linear equations over $\F_q$.
    \[\bigwedge_{i = 1}^m \bigvee_{j = 1}^{k_i} (f_j = \alpha_j)\]
\end{definition}

Linear CNF formulas can assume a complex structure such as the following:
\[((x_1+x_2 = 0) \lor (x_1 = 1)) \land ((x_2 + x_3 + x_4 = 3) \lor (x_2 + x_4 = 0))\]

We define \textbf{Linear Resolution over $\F_q$} (or $\mathsf{ResLin(\F_q)}$), an extension of standard Resolution (see \Cref{chap:bb-tfnp}) based on the following two rules:
\begin{enumerate}
    \item \textit{Resolution rule}: given two linear clauses $(f = 0) \lor C$ and $(f = 1) \lor D$ defined on $\F_q$, we can derive the linear clause $C \lor D$
    \item \textit{Weakening rule}: given a linear clause $C$, we can derive any linear clause $D$ such that $C \implies D$.
\end{enumerate}

Like in normal Resolution, in $\mathsf{ResLin(\F_q)}$ any derivation of a linear clause $C$ from a linear CNF $F$ is a sequence of linear clauses that ends with $C$, where every clause is either an axiom of $F$ or it can be derived from previous clauses through one of the two derivation rules. A linear CNF is unsatisfiable if and only if the empty linear clause can be derived from it. 

Any standard CNF formula can be described as a linear CNF formula over $\F_2$ simply by treating each clause as a disjunction of linear forms made of a single term. For example, the CNF $(x_1 \lor \lnot{x_2}) \land (\lnot{x_3} + x_1)$ can be written as the following linear CNF formula:
\[((x_1 = 1) \lor (x_2 = 0)) \land ((x_3 = 0) \lor (x_1 = 1))\]

We call this the \textit{linear encoding} of a CNF. From now on, we will restrict our interests to Linear Resolution over $\F_2$, also called \textit{parity Resolution} (or $\mathsf{Res}_\oplus$).

The weakening rule makes this proof system powerful thanks to how semantical implications can be used as \curlyquotes{shortcuts}. For example, consider the following linear CNF:
\[(x = 1) \land (x+y = 1) \land ((x = 0) \lor (y = 1))\]

\noindent
By rewriting the last linear clause as a negation of a conjunction, we notice that:
\[(x = 0) \lor (y = 1) \equiv \lnot ((x = 1) \land (y = 0))\]

\noindent
By simple substitution, we get that:
\[\lnot ((x = 1) \land (y = 0)) \implies  \lnot ((x = 1) \land (x+y = 1))\]

\noindent
which is equivalent to:
\[\lnot ((x = 1) \land (x+y = 1)) \equiv (x = 0) \lor (x+y = 0)\]

\noindent
concluding that $(x = 0) \lor (y = 1) \models (x = 0) \lor (x+y = 0)$. Proceeding with the resolution rule, we get the following Tree-like refutation.
\begin{figure}[H]
    \centering
    
    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=2.25cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]
    
        \node (1) []{$\bot$};
        
        \node (3) [above right of=1]{$(x = 0)$};
    
        \node (6) [above right of=3]{$(x=0) \lor (x+y = 0)$};
        
        \node (8) [above of=6]{$(x = 0) \lor (y = 1)$};
    
        \node (14) at ($(8)+(-4,0)$){$(x+y=1)$};
        \node (15) [left of=14]{$(x=1)$};
    
        \path[every node/.style={font=\sffamily\small}]
 (14) edge (3)
 (15) edge (1)
               
 (8) edge (6)
               
 (6) edge (3)
               
 (3) edge (1)
 ;
    \end{tikzpicture}

    \caption{$\mathsf{TreeRes}_\oplus$-proof of the previous linear CNF formula.}
    \label{treelike_proof}
\end{figure}

It was shown that the weakening rule can be simulated through these simple three rules \cite{res_lin_2}:
\begin{enumerate}
    \item \textit{Simplification rule}: given a linear clause $C \lor (0 = 1)$, we can derive the linear clause $C$
    \item \textit{Syntactic weakening}: given a linear clause $C$, we can derive the linear clause $C \lor (f = \alpha)$
    \item \textit{Addition rule}: given a linear clause $C \lor (f = \alpha) \lor (g = \beta)$, we can derive the linear clause $C \lor (f = \alpha) \lor (g = \beta)$
\end{enumerate}

\begin{proposition}
 Any clause obtainable through the weakening rule can also be obtained through a sequence of applications of the previous three rules and vice versa.
\end{proposition}

This result makes working with the weakening rule easier: any clause $D$ derived through $k$ applications of these three rules starting from a clause $C$ is automatically a weakening of $C$, implying that we can replace those $k$ applications with one single use of the weakening rule.

\section{Characterization of $\mathsf{FP}^{pdt}$ through $\mathsf{TreeRes}_\oplus$}

$\mathsf{TreeRes}_\oplus$ proofs and parity decision trees can be viewed as two sides of the same coin. Any tree-like $\ResP$ refutation of a linear CNF $F$ can be used to construct an (almost) equivalent PDT that solves $S_F$ and vice versa \cite{res_lin_2}.

\begin{lemma}
    \label{resp_to_pdt}
 Let $F$ be a linear CNF formula. If there is a $\mathsf{TreeRes}_\oplus$ refutation of $F$ with size $s$ and depth $d$, there also is a PDT of size at most $s$ and depth at most $d$ that solves $S_F$.
\end{lemma}

\begin{proof}
 Let $T$ be the proof tree that refutes $F$. We label each edge of $T$ whose associated clauses involve a resolution rule, while all the other weakening edges remain unlabeled. In particular, if a resolution rule is applied to the clauses $(f = 0) \lor D_1$ and $(f = 1) \lor D_2$ obtaining the clause $D_1 \lor D_2$, we label the edge from the first to the third with $f = 1$, while the other edge is labeled with $f = 0$.

 By induction on the depth of a node of $T$, we show that the clause written in $v$ contradicts the system $\Phi_v^T$. The root node contains the empty clause and is labeled by an empty system, making the statement trivially true. Assume now that the statement holds for a generic node $v$. We have to show that the hypothesis also holds for its children $u$ and $w$.

 Suppose that $v$ is the result of a resolution rule application, where $D_1 \lor D_2$ is the clause inside $v$. Assume that $u$ is the node that contains $(f = 0) \lor D_1$ while $w$ contains $(f = 1) \lor D_2$. By the inductive hypothesis, we know that $D_1 \lor D_2$ contradicts the system $\Phi_v^T$. This means that the set of equalities in $D_1$ contradicts $\Phi_v^T$. Moreover, we know that $\Phi_u^T = \Phi_v^T \land (f = 1)$, concluding that $(f = 0) \lor D_1$ contradicts $\Phi_u^T$. Likewise, we can show that $(f = 1) \lor D_2$ contradicts $\Phi_w^T$.
    
 Suppose now that $v$ is the result of a weakening rule, where $u$ is the only child. Since $(v,u)$ is unlabeled, we get that $\Phi_v^T = \Phi_u^T$. Furthermore, since $v$ is the result of a weakening applied to $u$, we know that the clause in $u$ semantically implies the clause in $v$, but by inductive hypothesis we know that the clause in $v$ contradicts the system $\Phi_v^T$, meaning that $u$ must also contradict the system $\Phi_v^T = \Phi_u^T$. Finally, if $v$ is a leaf then the statement is trivially true since it refutes a clause of $F$.

 By contracting all the unlabeled edges given by the weakening rules, we get a parity decision tree that solves $S_F$. Due to this final step, the size of the PDT is at most $s$ and its depth is at most $d$. 
\end{proof}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[circle, draw] (1)[] {$x$};

        \node[rectangle, draw] (2) [below left of=1, xshift=-20, ]{$x = 1$};
        \node[ellipse, draw] (3) [below right of=1, xshift=20, ]{$x+y$};

        \node[rectangle, draw] (4) [below left of=3, xshift=-20, yshift=-10]{$x+y = 1$};
        \node[rectangle, draw] (5) [below right of=3, xshift=20, yshift=-10]{$(x = 0) \lor (y = 1)$};

        \path[every node/.style={font=\sffamily\small}]
 (1) edge[swap]  node{0} (2)
 (1) edge node{1}(3)

 (3) edge[swap]  node{0} (4)
 (3) edge[]  node{1}(5)            
 ;
    \end{tikzpicture}

    \caption{The PDT obtained from the proof shown in \Cref{treelike_proof}.}
    \label{pdt_cnf}
\end{figure}

\begin{lemma}
    \label{pdt_to_resp}
 Let $F$ be a linear CNF formula. If there is a PDT of size $s$ and depth $d$ that solves $S_F$, there also is a $\mathsf{TreeRes}_\oplus$ refutation of $F$ with size at most $2s$, depth at most $d+1$ and the weakening rule applied only to the axioms.
\end{lemma}

\begin{proof}
 Let $T$ be a PDT of size $s$ and depth $d$ that solved $S_F$. By \Cref{degenerate}, we assume that $T$ is non-degenerate. We label every node $v$ of $T$ with the negation of its associated linear system. In other words, every node $v$ is labeled with the linear clause $\lnot \Phi_v^T$. Every node is the result of the resolution rule being applied to its children, where the root node is the empty clause.

 Since $T$ is a PDT that solves $S_F$, each leaf refutes a linear clause of $F$. Hence, for each leaf $u$ we have that $\Phi_{u}^T \implies \lnot C$ for some linear clause $C$ of $F$, which equivalently means that $C \implies \lnot \Phi_u^T$, concluding that the linear clause of each leaf is actually the weakening of a clause of $F$. Then, for each leaf $u$ we can add a new neighbor node $w$ and label it with the clause $C$, where the edge $(w,u)$ becomes an application of the weakening rule. This process increases the depth of the tree by 1 and increases the size by at most $s$.
\end{proof}

\begin{figure}[H]
    \centering
    
    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=2.25cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]
    
        \node (1) []{$\bot$};
        
        \node (3) [above right of=1, xshift = 50]{$(x = 0)$};
    
        \node (4) [above left of=3, xshift = -20]{$(x=0) \lor (x+y = 1)$};

        \node (6) [above right of=3, xshift = 20]{$(x=0) \lor (x+y = 0)$};

        
        \node (8) [above of=6]{$(x = 0) \lor (y = 1)$};
    
        \node (14) [above of = 4]{$(x+y=1)$};
        \node (15) [left of=14, xshift = -50]{$(x=1)$};
    
        \path[every node/.style={font=\sffamily\small}]
 (14) edge (4)
 (15) edge (1)
               
 (8) edge (6)
               
 (4) edge (3)
 (6) edge (3)
               
 (3) edge (1)
 ;
    \end{tikzpicture}

    \caption{$\mathsf{TreeRes}_\oplus$-proof obtained from the PDT shown in \Cref{pdt_cnf}.}
\end{figure}

We conclude that problems efficiently solvable parity decision trees are indeed characterized by Tree-like Linear Resolution over $\F_2$.

\begin{theorem}
    $\mathsf{FP}^{pdt}(S_F) = \Theta(\mathsf{TreeRes}_\oplus(F))$
\end{theorem}

\section{Known relations with other proof systems}

After defining the class $\mathsf{FP}^{pdt}$ and proving that $\mathsf{TreeRes}_\oplus$ characterizes it, we're interested in studying where this class lies in the \textsf{TFNP}$^{dt}$ hierarchy. It's a well-known fact that any $\mathsf{TreeRes}$ proof is also a $\mathsf{TreeRes}_\oplus$ due to the latter being an extension of the former. However, the reverse simulation easily doesn't hold due to $\mathsf{TreeRes}$ being a weaker proof system: the \textit{pebbling formulas on the XOR function} are hard for $\mathsf{TreeRes}$ but easy for $\mathsf{TreeRes}_\oplus$. This separation between the two proof systems also follows more naturally from our results since $\mathsf{FP}^{dt} \subsetneq \mathsf{FP}^{pdt}$ as shown in \Cref{fp_pdt_not_inside_fp_dt}, also raising the following question: parity clearly makes PDTs stronger than decision trees, but how much stronger?

We know that Tree-like Linear Resolution over $\F_2$ is strictly related to polynomials over the $\F_2$. In fact, it is already known \cite{treeres2_in_pc} that $\mathsf{TreeRes}_\oplus$ can be converted into a small proof in \textbf{Polynomial Calculus} over $\F_2$, an algebraic proof system. This proof system, as shown in \cite{tfnp_characterization}, characterizes the \curlyquotes{non-canonical} class $\mathsf{IND\text{-}PPA}^{dt}$, whose complete problem is $\mathrm{IND\text{-}LEAF}$, i.e. the inductive version of the $\mathrm{LEAF}$ problem. Thanks to \Cref{equiv_proof}, the previous result immediately concludes the following inclusion.

\begin{proposition}
    \label{fp_pdt_inside_ind_ppa_dt}
    $\mathsf{FP}^{pdt} \not\subseteq \mathsf{IND\text{-}PPA}^{dt}$
\end{proposition}

This inclusion rings a bell: looks like PDTs aren't actually that strong. Another proof system strictly related to polynomials over $\F_2$ is \textbf{Nullstellensatz}, another algebraic proof system. In general, it is known that Nullstellensatz is \textit{weaker} than Polynomial Calculus, even over the field $\F_2$.

Our first hypothesis was that $\mathsf{TreeRes}_\oplus$ could act as an intermediate step between the two algebraic systems. We tried to prove this result by showing that $\mathsf{LEAF}^{dt} \in \mathsf{FP}^{pdt}$, which appeared to be out of reach. We quickly shifted our perspective on trying to show that the simulation holds in the other direction. Indeed, we were capable of proving in our main theorem, i.e. \Cref{main_thm}, that any $\mathsf{TreeRes}_\oplus$ can be converted into a small $\mathrm{\F_2\text{-}NS}$ proof, providing a \textbf{black-box inclusion} for our new class. This also strengthens the previous relations showed in \cite{treeres2_in_pc}.

Moreover, in the seminal paper \cite{res_lin_2}, Itsykson and Sokolov discussed how $\mathsf{TreeRes}_\oplus$ cannot efficiently simulate regular Resolution (or $\mathsf{RegRes}$) - a restricted proof system derived from Resolution - due to the presence of harder types of pebbling formulas that separate them. Due to any regular Resolution proof also being a Resolution proof, this result also implies that $\mathsf{TreeRes}_\oplus$ cannot efficiently simulate $\mathsf{Res}$. Again, thanks to \Cref{equiv_proof} and to the fact that $\mathrm{PLS}^{dt}(S_F) = \Theta(\mathsf{Res}(F))$, we conclude the following black-box separation.

\begin{proposition}
    \label{pls_dt_not_inside_fp_pdt}
    $\mathsf{PLS}^{dt} \not\subseteq \mathsf{FP}^{pdt}$
\end{proposition}

\section{Nullstellensatz over $\F_2$ and the class $\mathsf{PPA}^{dt}$}

In 1893, the mathematician Hilbert proved a theorem that established the basis of algebraic geometry, a field that studies the relations between algebra and geometry. This theorem is now known as Hilbert's \textbf{Nullstellensatz} (german for \textit{zero-locus theorem}).

The \textit{weak Nullstellensatz}, a corollary of the stronger theorem, states that given $m$ polynomials $p_1, \ldots, p_m$ defined on $F[x_1, \ldots, x_n]$, where $\F$ is a generic algebraic field, the system $p_1(x) = p_2(x) = \ldots = p_m(x) = 0$ is unsolvable if and only if there are $m$ polynomials $g_1, \ldots, g_m$ defined on $F[x_1, \ldots, x_n]$ such that $\sum_{i=1}^m g_ip_i = 1$.

This weaker version of the theorem has been used to define an \textit{algebraic} proof system, that being a proof system based on polynomial algebra. Intuitively, these proof systems are based on the idea of showing that a set of polynomials $p_1, \ldots, p_m$, called \textit{axioms}, doesn't share a common root, which serves as a proof for the polynomials. In this case, a Nullstellensatz proof is given by the set of polynomials $g_1, \ldots, g_m$ through which we get that $\sum_{i=1}^m g_ip_i = 1$  \cite{ns_definitions}. 

Any CNF formula can be translated to an \textit{algebraic encoding}, a set of polynomials $p_1, \ldots, p_m$ for which the CNF formula is unsatisfiable if and only if there is a Nullstellensatz proof for $p_1, \ldots, p_m$. Given the clause $C = \bigvee_{i = 1}^k x_i \lor \bigvee_{j = 1}^h \lnot y_j$, the algebraic encoding of $C$, written as $p_C$, is given by $p_C := \prod_{i = 1}^{k} x_i \cdot \prod_{j = 1}^h (1- y_j)$. 

To clear things up, we notice that through this formulation the concept of truthfulness is \textbf{inverted}: the boolean values $0$ and $1$ respectively correspond to the algebraic values $1$ and $0$. For example, the boolean clause $C$ evaluates to 1 when at least a literal inside it evaluates to 1, while an algebraic clause evaluates to 0 when at least a literal inside it evaluates to 0.

The algebraic encoding of a CNF formula $F = C_1 \land \ldots \land C_m$ is given by the set of polynomial equations $p_F = \{p_{C_1} = 0, \ldots, p_{C_m} = 0, x_1^2-x_1 = 0, \ldots, x_n^2-x_n = 0\}$. These last polynomials are necessary to impose that the values of $x_1, \ldots, x_n$ are either a 0 or a 1. A Nullstellensatz \textit{refutation} for $F$ is given by the polynomials $g_1, \ldots, g_m, h_1, \ldots, h_n$ such that:
\[\sum_{i = 1}^m g_ip_{C_i} + \sum_{j = 1}^m h_j(x_j^2-x_j) = 1\]
In order for the CNF $F$ to be satisfied by an assignment $x$, each clause must evaluate to 1, while in Nullstellensatz the polynomials inside $p_F$ must all evaluate to 0. 

\begin{figure}[H]
    \centering
    \begin{tabular}{r c l}
 0 & $\longrightarrow$ & 1 \\
 1 & $\longrightarrow$ & 0 \\
        $x_i$ & $\longrightarrow$ & $x_i$ \\
        $\lnot x_i$ & $\longrightarrow$ & $1-x_i$ \\
        $C \lor D$ & $\longrightarrow$ & $C \cdot D$ \\
        $C \land D$ & $\longrightarrow$ & $C + D$ \\
    \end{tabular}

    \caption{Mappings from boolean encoding to algebraic encoding.}
\end{figure}

\noindent
When a polynomial $q$ can be derived from a set of axioms $P$, we write $P \stackrel{\mathsf{NS}}{\vdash} q$. If $F$ is a CNF formula and $P \stackrel{\mathsf{NS}}{\vdash} 1$ then we get a Nullstellensatz refutation. Consider the CNF formula $x_1 \land (\lnot x_1 \lor x_2) \land (\lnot x_2 \lor x_3) \land (\lnot x_3 \lor x_4)\land x_4$. The algebraic encoding is given by $p_1 = x_1$, $p_i = (1-x_{i-1})x_i$ when $2 \leq i \leq 4$ and $p_5 = 1-x_4$. To refute this CNF, we must find the polynomials $g_1, \ldots, g_5, h_1, \ldots, h_4$ through which
\[\sum_{i = 1}^5 g_ip_{i} + \sum_{j = 1}^4 h_j(x_j^2-x_j) = 1\]

\noindent
To simplify things, we let $h_1, \ldots, h_4 = 0$ in order to have $\sum_{j = 1}^4 h_j(x_j^2-x_j) = 0$. Let $g_1, \ldots, g_5$ be equal to:
\[g_1 = x_2x_3x_4 \qquad g_2 = x_3x_4 \qquad g_3 = x_4 \qquad g_4 = g_5 = 1\]

\noindent
We easily get that:
\[\begin{split}
    \sum_{i = 1}^5 g_ip_{i}&= x_1x_2x_3x_4 + (1-x_1)x_2x_3x_4 + (1-x_2)x_3x_4 + (1-x_3)x_4 + (1-x_4)\\
    &= x_2x_3x_4 + (1-x_2)x_3x_4 + (1-x_3)x_4 + (1-x_4)\\
    &= x_3x_4 + (1-x_3)x_4 + (1-x_4)\\
    &= x_4 + (1-x_4)\\
    &= 1\\
\end{split}\]
concluding that $P_F \stackrel{\mathsf{NS}}{\vdash} 1$ and thus proving that the CNF is unsatisfiable. In Nullstellensatz, the \textit{size} of a proof is the total number of monomials of the polynomials that make the proof, i.e. the total number of terms in the sum once fully expanded without simplifying any addition (or subtraction). The \textit{degree} of the proof is the maximum degree of any polynomial $g_ip_i$ or $h_j(x^j+x_j)$. For example, the polynomial $(1-x_1)(1-x_2)x_2x_3$ has size 4 and degree 4 since $(1-x_1)(1-x_2)x_2x_3 = x_2x_3 - x_2^2x_3 - x_1x_2x_3 + x_1x_2^2x_3$. The previous proof has size $1+2+2+2+2 = 9$ and degree $4$.

Nullstellensatz's degree measure vaguely resembles Resolution's width measure. For example, the algebraic encoding of a CNF clause $C$ of width $w$ clearly has degree $w$. Moreover, it's easy to see that a degree upper bound $d$ for the Nullstellensatz refutation of a CNF formula defined on $n$ variables implies a size upper bound of $n^{O(d)}$. This result enables us to restrict our interest to the degree of the proof.

\begin{proposition}
    \label{degree_size}
 Given a CNF formula $F$ defined on $n$ variables, if $P_F \stackrel{\mathsf{NS}}{\vdash} 1$ with degree $O(d)$ then the size of the proof is $n^{O(d)}$.
\end{proposition}

A common result shows that in Nullstellensatz proofs we can assume that polynomials are \textit{multilinear} (short for \textit{multivariate and linear}), meaning that each variable of each term has algebraic multiplicity equal to at most 1. For example, the polynomial $xy+yz$ is multilinear, while $x^2y$ isn't. This assumption affects the degree of the proof only by a constant factor, allowing us to work more easily.

As shown in \Cref{TFNP_dt_hierarchy}, $\F_2$-Nullstellensatz characterizes the black-box version of the class $\mathsf{PPA}$, the class of total search problems that are reducible to the \textbf{Polynomial Parity Argument (PPA)}, first defined by Papadimitriou \cite{PPA_complexity}.

Suppose we are given a polynomial-size circuit $C$ with $n$ input bits and $n$ output bits. For each possible input $x \in \{0,1\}^n$, the circuit provides a pair $(p,s) \in \{0,1\}^n \times \{0,1\}^n$ where $p$ and $s$ are the predecessor and successor of $x$. This circuit generates a graph $G_C$ with $2^n$ nodes, where $(u,v) \in E(G_C)$ if and only if $u$ is the predecessor of $v$ and $v$ is the successor of $u$. By construction, each node has at most two neighbor nodes and some nodes may even be disconnected.

The canonical \textsf{PPA}-Complete problem is $\mathrm{LEAF}$: given a specific node - usually assumed to be the $0 \ldots 0$ node - with an odd number of neighbors inside the graph $G_C$ generated by $C$, we are required to find another odd-degree node. The solution to this problem is guaranteed to exist thanks to the \textbf{Handshaking lemma}, which states that every undirected graph has an even number of odd-degree nodes. The hardness of the question comes from the impossibility of using common path-traversing algorithms to find the solution: the graph has exponential size with respect to the input size!

\begin{figure}[H]
    \centering
    
    \resizebox{0.9\hsize}{!}{
        \begin{tikzpicture}[-,>=stealth,shorten >=1pt,auto,node distance=2cm, thick,main node/.style={scale=0.8,circle,draw,font=\sffamily\normalsize}]
        
            \node[circle, draw] (1)[]{$0000$};
            \node[circle, draw] (2)[below right of = 1]{$0001$};
            \node[circle, draw] (3)[below left of = 2]{$0010$};
            \node[circle, draw] (4)[above right of = 2]{$1110$};
            \node[circle, draw] (5)[below right of = 2]{$0100$};
            \node[circle, draw] (6)[below right of = 4]{$1011$};
            \node[circle, draw] (7)[above right of = 6]{$0110$};
            \node[circle, draw] (8)[below right of = 6]{$1101$};
            \node[circle, draw] (9)[below right of = 7]{$1000$};
            \node[circle, draw] (10)[above right of = 9]{$1001$};
            \node[circle, draw] (11)[below right of = 9]{$1010$};
            \node[circle, draw] (12)[below right of = 10]{$0101$};
            \node[circle, draw] (13)[above right of = 12]{$1100$};
            \node[circle, draw] (14)[below right of = 12]{$0111$};
            \node[circle, draw] (15)[below left of = 1]{$0011$};
            \node[circle, draw] (16)[below right of = 13]{$1111$};
        
            \path[every node/.style={font=\sffamily\small}]
 (1) edge (4)
 (2) edge (3)
 (4) edge (6)
 (2) edge (5)
 (3) edge (5)
 (6) edge (7)
 (9) edge (8)
 (8) edge (7)
 (12) edge (7)
 (13) edge (14)
 ;
        \end{tikzpicture}
 }
    \caption{The circuit input is made of 4 bits and the generated graph has $2^4$ vertices.}
\end{figure}


Through \Cref{equiv_proof}, we know that an efficient proof for a formula $F$ directly implies that its search problem $S_F$ is actually efficiently reducible to the black-box version of the $\mathrm{LEAF}$ problem. In the following section, we show how to convert an efficient $\mathrm{TreeRes}_\oplus$ into an efficient $\F_2$-Nullstellensatz proof, proving that each problem efficiently solvable through a PDT is reducible to an instance of $\mathrm{LEAF}^{dt}$, which implies that $\mathsf{FP}^{pdt} \subseteq \mathsf{PPA}^{dt}$.

\section{From $\mathsf{TreeRes}_\oplus$ to $\F_2$-Nullstellensatz}

We prove that Nullstellensatz over $\F_2$ is capable of efficiently simulating $\mathrm{TreeRes}_\oplus$. Given the linear clause $C = \bigvee_{i = 1}^k (f_i = \alpha_i)$, the algebraic encoding of $C$, written as $p_C$, is given by $p_C := \prod_{i = 1}^{k} (f_i + a_i)$. The algebraic encoding of a linear CNF formula $F = C_1 \land \ldots \land C_m$ is given by the set of polynomial equations $p_F = \{p_{C_1} = 0, \ldots, p_{C_m} = 0, x_1^2-x_1 = 0, \ldots, x_n^2-x_n = 0\}$.

To achieve our result, we first convert the $\mathrm{TreeRes}_\oplus$ proof into an (almost) equivalent proof through the method shown in \Cref{chap:parity-tfnp} and then balance the degree of the $\mathsf{\F_2-NS}$ proof obtained from the tree-like proof. The following result follows from \Cref{resp_to_pdt} and \Cref{pdt_to_resp}.

\begin{corollary}
    \label{leaf_weakening}
 Every $\mathsf{TreeRes}_{\oplus}$ proof of size $s$ and depth $d$ can be converted to a $\mathsf{TreeRes}_{\oplus}$ proof of size $O(s)$, degree $O(d)$ and with the weakening rule applied only to the axioms.
\end{corollary}

Next, we prove some basic Nullstellensatz inspired by the ones shown in \cite{groebner}, which allow us to manipulate and combine different types of proofs. We will use these properties to inductively simulate the resolution rule.

Given a formula $F$, we denote with $F_{\mid_{f = \alpha}}$ the formula obtained by substituting $f$ with $\alpha$ inside $F$. This is usually called \textbf{restriction of $F$ on $f = \alpha$}. In particular, we notice that if $F$ is a CNF formula then by restricting it on $f = 0$ any clause $C \lor (f = 0)$ becomes $C \lor (0 = 1)$, which is equivalent to $C$ through weakening. If we restrict $F$ on $f = 1$, any clause $C \lor (f = 0)$ becomes $C \lor (1=1)$, which directly evaluates to $1$.
In a similar fashion, given the polynomial $p$ we denote with $p_{\mid_{f = \alpha}}$ the restriction of $p$ on $f = \alpha$, i.e. the polynomial obtained by setting $f$ equal to $\alpha$ in $p$.

\begin{lemma}
    \label{ns_properties}
 Given the multilinear polynomials $p_1, \ldots, p_k$ over $\F_2$ of degree at most $d$ and a linear form $f$, it holds that:
    \begin{enumerate}
        \item If $p_1, \ldots, p_k, f \vdash 1$ with degree $d$ then $p_1, \ldots, p_k \vdash 1-f$ with degree $d+1$.
        \item If $p_1, \ldots, p_k, 1-f \vdash 1$ with degree $d$ then $p_1, \ldots, p_k \vdash f$ with degree $d+1$.
        \item $p_i, f \vdash p_{i \mid_{f=0}}$ with degree $d$ 
        \item $p_i, 1-f \vdash p_{i \mid_{f=1}}$ with degree $d$ 
        \item If $p_{1\mid_{f=0}}, \ldots, p_{k\mid_{f=0}} \vdash 1$ with degree $d$ and $p_{1\mid_{f=1}}, \ldots, p_{k\mid_{f=1}} \vdash 1$ with degree $d+1$, then $p_1, \ldots, p_k \vdash 1$ with degree $d+1$
        \item If $p_{1\mid_{f=0}}, \ldots, p_{k\mid_{f=0}} \vdash 1$ with degree $d+1$ and $p_{1\mid_{f=1}}, \ldots, p_{k\mid_{f=1}} \vdash 1$ with degree $d$, then $p_1, \ldots, p_k \vdash 1$ with degree $d+1$
    \end{enumerate}
\end{lemma}

\begin{proof}
 We proceed claim by claim:
    \begin{enumerate}
        \item Since $g_{k+1}f + \sum_{i = 1}^k g_i p_i = 1$, we easily get that:
        \[(1-f)g_{k+1}f + (1-f)\sum_{i = 1}^k g_i p_i = 1-f\]
        
 Moreover, since $(1-f) f = 0$ due to $f$ being defined on $\F_2$, we can remove $f$ from the proof, concluding that $(1-f)\sum_{i = 1}^k g_i p_i = 1-f$ with degree incremented by one due to  $f$ being a linear form.
    
        \item Similar to claim 1 of this lemma: multiply the whole proof by $f$.
        
        \item Let $p = f p_1 + p_0$, where $p_1$ and $p_0$ are independent of $f$. By restricting $p$ on $f = 0$ we get that $p_{\mid_{f=0}} = 0 \cdot p_1 + p_0 = p_0 = p - f p_1$. Since $p$ has degree at most $d$ and $f$ has degree 1, $p_1$ must have degree at most $d-1$, thus $p - f p_1 = p_{\mid_{f=0}}$ is a proof of degree at most $d$.
        
        \item Similar to claim 3 of this lemma: by restricting $p$ on $f=1$ we obtain that $p_{\mid_{f=1}} = p_1 + p_0 = p_1 + p_0 + fp_1 - fp_1 = p+(1-f)p_1$, thus $p + (1-f)p_1 = p_{\mid_{f=1}}$ is a proof of degree at most $d$.

        \item Through the previous claims of this lemma $p_1, \ldots, p_k, f \vdash p_{1\mid_{f=0}}, \ldots, p_{k\mid_{f=0}} \vdash 1$ with degree $d$. Then, by the first claim of this lemma, we know that $p_1, \ldots, p_k, f \vdash  1$ with degree $d$ implies that $p_1, \ldots, p_k \vdash 1-f$ with degree $d+1$. Likewise, we have that $p_1, \ldots, p_k, 1-f \vdash p_{1\mid_{f=1}}, \ldots, p_{k\mid_{f=1}} \vdash 1$ with degree $d+1$. Finally, since $p_1, \ldots, p_k \vdash 1-f$ and $p_1, \ldots, p_k, 1-f \vdash 1$ both with degree $d+1$, by concatenating the two proofs we get that $p_1, \ldots, p_k \vdash 1$ with degree $d+1$.

        \item Similar to claim 5 of this lemma: invert the roles of the two initial proofs and use the second claim of this lemma.
    \end{enumerate}
\end{proof}

\begin{lemma}
    \label{union_ref}
 Given two disjoint axiom sets $P_1, P_2$ of multilinear polynomials over $\F_2$, if $P_1, p \vdash 1$ with degree $d_1$ and $P_2, 1-p \vdash 1$ with degree $d_2$ then $P_1, P_2 \vdash 1$ with degree $d_1 + d_2$.
\end{lemma}

\begin{proof}
 Assume that $P_1 = \{p_1, \ldots, p_m\}$ and $P_2 = \{q_1, \ldots, q_k\}$ and let $p_{m+1} = p$ and $q_{k+1} = 1-p$. Since $\sum_{i = 1}^{m+1} g_i p_i + \sum_{j = 1}^n a_j (x_j^2-x_j) = 1$ for some $g_1, \ldots, g_{m+1}$, we that:
\[\sum_{i = 1}^{m} g_i p_i + \sum_{j = 1}^n a_j (x_j^2-x_j) = 1 - g_{m+1} p_{m+1} = 1-g_{m+1} p\]
    
\noindent
 Likewise, since $\sum_{i = 1}^{k+1} h_i q_i + \sum_{j = 1}^n b_j (x_j^2-x_j) = 1$ for some $h_1, \ldots, h_{k+1}$, we get that:
\[\sum_{i = 1}^{k} h_iq_i + \sum_{j = 1}^n b_j (x_j^2-x_j) = 1-h_{k+1}q_{k+1} = 1-h_{k+1}(1-p)\]

\noindent
 We notice that:
    \[\begin{split}
 (1-p) \left (\sum_{i = 1}^{m} g_i p_i + \sum_{j = 1}^n a_j (x_j^2-x_j) \right ) &= (1-p)(1-g_{m+1} p) \\
        &= 1-p - g_{m+1}p (1-p) \\
        &= 1-p
    \end{split}\]
 with degree $d_1+d_2$. In the last step, we used the fact that $p(1-p) = 0$ holds in $\F_2$. Similarly, we get that:
    \[\begin{split}
 p\left (\sum_{i = 1}^{k} h_iq_i + \sum_{j = 1}^n b_j (x_j^2-x_j)  \right ) &= p 
    \end{split}\]
 again with degree $d_1+d_2$. By summing these two proofs, we get that 
    \[(1-p) \left (\sum_{i = 1}^{m} g_i p_i + \sum_{j = 1}^n a_j (x_j^2-x_j) \right ) + p \left (\sum_{i = 1}^{k} h_iq_i + \sum_{j = 1}^n b_j (x_j^2-x_j) \right )= 1\]
 concluding that $P_1, P_2 \vdash 1$ with degree $d_1 + d_2$.
\end{proof}

Next, we prove that a Tree-like Linear Resolution over $\F_2$ can be efficiently converted into a small $\F_2$-Nullstellensatz proof. The very same proof can be used to also show that standard Tree-like Linear Resolution can be simulated by $\F_2$-Nullstellensatz, an already known result.

\begin{lemma}
    \label{treeref_no_weak}
 Let $F$ be an unsatisfiable CNF. If $T$ is $\mathsf{TreeRes}_\oplus$ refutation of $F$ of size $s$ and width $w$ that uses only the resolution rule then there is $\F_2\text{-}\NS$ refutation of $F$ of degree $w+\log_2 s$.
\end{lemma}

\begin{proof}
 Let $F = C_1 \land \ldots \land C_k$. We proceed by strong induction on the size $s$ of $T$. When $S = 1$, one of the axioms of $F$ must be the empty clause, hence $p_{C_i} \vdash 1$ for some $i$ and by extension that $p_{C_i}, \ldots, p_{C_k} \vdash 1$.

 Suppose now that $s > 1$. Let $f = 0$ and $f = 1$ be the two clauses that derive the empty clause $\bot$ in $T$. These two clauses are derived through two subtrees $T_0, T_1$ of sizes $s_0, s_1$, where $s = s_0+s_1+1$. 
    
 By restricting $T_0$ on $f = 1$, the tree $T_{0 \mid_{f = 1}}$ is a $\mathsf{TreeRes}_\oplus$ proof of the formula $C_{1 \mid_{f = 1}} \land \ldots \land C_{k \mid_{f = 1}}$ of size $s_1$. Since $T$ uses only the resolution rule, $T_0$ also does. Then, my induction, we have that $p_{C_{1 \mid_{f = 1}}}, \ldots, p_{C_{k \mid_{f = 1}}} \vdash 1$ with degree $w + \log_2 s_1$. Using a similar argument, the tree $T_{1 \mid_{f = 0}}$ produces a proof $p_{C_{1 \mid_{f = 0}}}, \ldots, p_{C_{k \mid_{f = 0}}} \vdash 1$ with degree $w + \log s_2$.

 If $s_1 < \frac{s}{2}$, then $w + \log_2 s_1 \leq w + \log_2 s - 1$. Thus, the proof $p_{C_{1 \mid_{f = 1}}}, \ldots, p_{C_{k \mid_{f = 1}}} \vdash 1$ is also a proof of degree $w + \log_2 s - 1$, while the proof $p_{C_{1 \mid_{f = 0}}}, \ldots, p_{C_{k \mid_{f = 0}}} \vdash 1$ is also a proof of degree $w + \log_2 s$. By the fifth claim of \Cref{ns_properties}, we conclude that $p_{C_i}, \ldots, p_{C_k} \vdash 1$ with degree $w + \log_2 s$.

 If $s_2 < \frac{s}{2}$, instead, we get a symmetric proof, where the role of the two proofs is swapped. By the sixth claim of \Cref{ns_properties}, we again conclude that $p_{C_i}, \ldots, p_{C_k} \vdash 1$ with degree $w + \log_2 s$.
\end{proof}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[<-,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[] (1) []{$\bot$};

        \node[] (2a) [above left of=1, xshift=-30, yshift=10]{$f = 0$};
        \node[] (2d) [above of=2a, yshift=-40]{};
        \node[] (2b) [above left of=2d, yshift=10]{};
        \node[] (2c) [above right of=2d, yshift=10]{};
        \node[] (2e) [above of=2a, yshift=-10]{$T_0$};

        \node[] (3a) [above right of=1, xshift=30, yshift=10]{$f = 1$};
        \node[] (3d) [above of=3a, yshift=-40]{};
        \node[] (3b) [above left of=3d, yshift=10]{};
        \node[] (3c) [above right of=3d, yshift=10]{};
        \node[] (3e) [above of=3a, yshift=-10]{$T_1$};

        \path[every node/.style={font=\sffamily\small}, -]
 (2d.center) edge (2b.center)
 (2d.center) edge (2c.center)
 (2b.center) edge (2c.center)
 ;
        
        \path[every node/.style={font=\sffamily\small}, -]
 (3d.center) edge (3b.center)
 (3d.center) edge (3c.center)
 (3b.center) edge (3c.center)
 ;

        \path[every node/.style={font=\sffamily\small}]
 (1) edge (2a)
 (1) edge (3a)
 ;

    \end{tikzpicture}

    \caption{Representation of the idea behind \Cref{treeref_no_weak}.}
\end{figure}

The weakening rule is generally hard to simulate through $\F_2$-Nullstellensatz. However, if $D$ is derived through weakening from an axiom clause $C_i$ of a CNF formula $F$, we can easily simulate this rule. This result is enough for our purposes but it can also be extended to derivations from a non-axiom clause with a little blow-up in degree. 

\begin{lemma}
    \label{weakening_ns}

 Let $F = C_1 \land \ldots \land C_m$ be a CNF formula and let $D$ be a linear clause. If $C_i \implies D$ then $p_{C_i} \vdash p_D$ with degree $d+k$, where $d$ is the width of $D$ and $k$ is the width of $C_i$.
\end{lemma}

\begin{proof}
 Let $C := C_i$. Assume $C = \bigvee_{i = 1}^k (x_i = \alpha_1)$ and $D = \bigvee_{j = 1}^d (f_j = \beta_j)$. We notice that any polynomial $q(1+q)$ can be derived with degree 2 from axioms. 
        \[(y_1 + \ldots + y_t)(y_1 + \ldots y_t + 1) = \sum_{i = 1}^t y_i^2 + \sum_{i = 1}^t y_i + 2 \sum_{i \neq j} y_i y_j = \sum_{i = 1}^t y_i^2 + y_i\]
 since $2 = 0$ in $\F_2$. This implies that for each $j \in [d]$ we can derive $f_j+\beta_j+1$ with degree $d+1$.

 Since $C \implies D$, this can only happen if each $x_i + \alpha_i$ is a linear combination of $(f_1 + \beta_1 + 1), \ldots, (f_d + \beta_d + 1)$, concluding that each $p_D(x_i+\alpha_i)$ is derivable in $\F_2$-Nullstellensatz with degree $d+1$. Finally, we notice that:
        \[p_D = p_C + p_D(x_1+\alpha_1+1) + p_D(x_2+\alpha_2+1)(x_1+\alpha_1)+ \ldots + p_D(x_d+\alpha_d+1)+\prod_{i = 0}^{d-1} (x_i+\alpha_i)\]
 which is a derivation of $p_D$ from $p_{C}$ with degree $d + k$.
\end{proof}

\begin{theorem}
    \label{main_thm}
 Let $F$ be an unsatisfiable CNF. If $T$ is $\mathsf{TreeRes}_\oplus$ refutation of $F$ of size $s$ and width $w$ then there is $\NS$ refutation of $F$ of degree $O(w + \log s)$.
\end{theorem}

\begin{proof}
 Let $F = C_1 \land \cdots \land C_m$ and let $T$ be a $\mathsf{TreeRes}_\oplus$-proof of $F$ with size $s$ and width $w$. Through \Cref{leaf_weakening} we know that there must also be a $\mathsf{TreeRes}_\oplus$-proof of size $O(s)$ with the weakening rule applied only to the leaves. Let $\widehat{C_1}, \ldots, \widehat{C_m}$ be the linear clauses obtained through such weakening rules and let $T'$ be the subtree.

 Let $T'$ be the subtree of $T$ with root $\bot$ and leaves $\widehat{C_1}, \ldots, \widehat{C_m}$. Since $T'$ only uses the resolution rule, by \Cref{treeref_no_weak} we conclude that $p_{\widehat{C_1}}, \ldots, p_{\widehat{C_m}} \vdash 1$ with degree $O(w + \log s)$. Clearly, this also implies that $\mathrm{deg}(p_{\widehat{C_i}}) = O(w + \log s)$ for all $i$.
        
 Since each $\widehat{C_i}$ is a weakening of $C_i$, by \Cref{weakening_ns} we know that $p_{C_i} \vdash p_{\widehat{C_i}}$ with degree $O(w + \log s)$. We trivially get that $p_{C_i}, (1-p_{\widehat{C_i}}) \vdash 1$ with degree $O(w + \log s)$. Moreover, since $p_{\widehat{C_1}}, \ldots, p_{\widehat{C_m}} \vdash 1$ with degree $O(w + \log s)$, by \Cref{union_ref} we get that $p_{C_1}, p_{\widehat{C_2}}, \ldots, p_{\widehat{C_m}} \vdash 1$ with degree $O(w + \log s)$. After repeating this process for each weakening clause, we finally conclude that $p_{C_1}, \ldots, p_{C_m} \vdash 1$ with degree $O(w + \log s)$. 
\end{proof}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=1.75cm, thick,main node/.style={scale=0.9,circle,draw,font=\sffamily\normalsize}]

        \node[] (2) []{};

        \node[] (2a) [above left of=2, xshift=-50, yshift=100]{};
        \node[] (2b) [above right of=2, xshift=50, yshift=100]{};
        \node[] (2c) [below of=2, yshift=40]{$\bot$};
        \node[] (2d) [above of=2, yshift = 30]{$T$};

        \node[] (4) [above of = 2a, yshift = -37.5]{$\widehat{C_1}$};
        \node[] (5) [above of = 2a, yshift = -37.5, xshift=30]{$\widehat{C_2}$};
        \node[] (6) [above of = 2a, yshift = -37.5, xshift=60]{$\cdots$};
        \node[] (7) [above of = 2a, yshift = -37.5, xshift=85]{$\cdots$};
        \node[] (8) [above of = 2b, yshift = -37.5]{$\widehat{C_m}$};
        \node[] (9) [above of = 2b, yshift = -37.5, xshift=-30]{$\widehat{C_{m-1}}$};
        \node[] (10) [above of = 2b, yshift = -37.5, xshift=-60]{$\cdots$};


        \node[] (11) [above of = 2a]{${C_1}$};
        \node[] (12) [above of = 2a, xshift=30]{${C_2}$};
        \node[] (13) [above of = 2a, xshift=60]{$\cdots$};
        \node[] (14) [above of = 2a, xshift=85]{$\cdots$};
        \node[] (15) [above of = 2b]{${C_m}$};
        \node[] (16) [above of = 2b, xshift=-30]{${C_{m-1}}$};
        \node[] (17) [above of = 2b, xshift=-60]{$\cdots$};

        \path[every node/.style={font=\sffamily\small}, -]
 (4) edge (11)
 (5) edge (12)
 (8) edge (15)
 (9) edge (16)
 ;

        \path[every node/.style={font=\sffamily\small}, -]
 (2.center) edge (2a.center)
 (2.center) edge (2b.center)
 (2a.center) edge (2b.center)
 ;

    \end{tikzpicture}

    \caption{Representation of the idea behind \Cref{main_thm}.}
\end{figure}

Finally, thanks to \Cref{equiv_proof} and the fact that $\mathrm{PPA}^{dt}(S_F) = \Theta(\F_2\text{-}\mathsf{NS}(F))$, the last theorem proves that our new class is indeed contained inside $\mathsf{PPA}^{dt}$, meaning that any total search problem efficiently solvable by a parity decision tree can be reduced to an instance of the parity argument problem.  
   
\begin{theorem}
    \label{final_inclusion}
    $\mathsf{FP}^{pdt} \subseteq \mathsf{PPA}^{dt}$
\end{theorem}

\begin{proof}
 Suppose that $R \in \mathsf{FP}^{pdt}$. By definition, there is a PDT that solves $R$ with size $s$ and depth $d$, where $d+\log s = O(\log^k n)$ for some $k \in \N$. We know that each $\textsf{TFNP}^{dt}$ is equivalent to the false clause search problem of some CNF formula $F$, thus $R = S_F$.
    
 By \Cref{pdt_to_resp}, we know that there is a \textsf{TreeRes}$_{\oplus}$ proof of $F$ with size $O(s)$ and depth $d$. Then, by theorem \Cref{main_thm}, we know that there must be a $\F_2$-Nullstellensatz refutation for $F$ with degree $O(w + \log s)$ and size $n^{O(w + \log s)}$, where $w$ is the width of the tree-like proof.
 
 We get that the total Nullstellensatz complexity of the proof $F$, given by the sum of the depth and the logarithm of the size, corresponds to $(w + \log s) + \log(n^{O(w + \log s)}) = O(\log^{k+1} n)$, hence $F$ has a polylogarithmic $\F_2$-\textsf{NS} refutation. By \Cref{equiv_proof}, this implies that there is an efficient reduction $S_F \leq_m \mathsf{PPA}^{dt}$, concluding that $R \in \mathsf{PPA}^{pdt}$
\end{proof}
   

\cleardoublepage
