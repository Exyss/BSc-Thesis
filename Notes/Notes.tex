\documentclass[a4paper, 12pt]{report}

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../packages/Nyx/nyx-packages}
\usepackage{../packages/Nyx/nyx-styles}
\usepackage{../packages/Nyx/nyx-frames}
\usepackage{../packages/Nyx/nyx-title}
\usepackage{../packages/Nyx/nyx-macros}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../packages/Nyx/logo.png}

\institute{\curlyquotes{\hspace{0.25mm}Sapienza} Universit√† di Roma}
\faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
\department{Dipartimento di Informatica}

\title{Appunti tesi}
\subtitle{}

\author{\textit{Author}\\Simone Bianco}
% \author{\textit{Author}\\Alessio Bandiera}
% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\date{\today}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    %%%%%%%%%%%%%%%

    \chapter{Outline}

    Analysis of connections between total search problems (\textsf{TFNP}), proof complexity, communication complexity and circuit complexity.

    Given a formula $F \in \mathsf{UNSAT}$ and a partition $X,Y$ of its variables, it holds that:

    \[F \text{ has a proof in resolution of depth at most } d \iff \]
    \[\mathrm{Search}(F) \text{ has a decision tree of depth at most } d \implies \]
    \[\mathrm{Search}^{X,Y}(F) \text{ is computed by a protocol of length at most } d \iff \]
    \[\mathrm{mKW}(\mathrm{cert}^{X,Y}_F) \text{ is computed by a protocol of length at most } d \iff \]
    \[\mathrm{cert}^{X,Y}_F \text{ is computed by a formula of depth at most } d \]


    \quad

    \underline{Question}: is it true that 
    \[\mathrm{Search}^{X,Y}(F) \text{ is computed by a protocol of length at most } d \]
    \[\implies \mathrm{Search}(F) \text{ has a decision tree of depth at most } d \; ?\]

    \chapter{Resolution and decision trees (Proof complexity)}

    \chapter{Protocols (Communication complexity)}

    \chapter{Boolean circuits (Circuit complexity)}

    \section{Definition}

    \begin{frameddefn}{Boolean circuit}
        A \textbf{boolean circuit} is a directed acyclic graph whose vertices are associated with either Boolean operators or input literals. In particular, the first type of vertices are called \textit{gates}.
        
        Every vertex with in-degree 0 corresponds to a constant bit or an input literal (an input variable or its negation), while all the other vertices (the gates) are associated with a \textbf{logical operator}. Each gate takes values as inputs, which can either be the result of another gate, an input literal or constant. These input values are represented by an incoming edge of the gate.
    \end{frameddefn}

    The set of available logical operators is called \textit{base} of the circuit. Usually, this set is restricted to the operators $\{\land, \lor\}$.
    
    Given a boolean circuit, we define as \textit{size} the number of gates of the circuit and as \textit{depth} the length of the longest directed path in the underlying graph.

    We say that a boolean circuit \textbf{computes} the function $f$ if the function $f_v$ described by the \textit{top gate} of the circuit (the only node with out-degree 0) is equivalent to the result given by $f$, meaning that $f = f_v$.

    Given a function $f$, we define the \textbf{circuit complexity of $f$} as the size of the smallest circuit that computes it. Every function $f$ that can be computed by an algorithm in $T(n)$ steps can also be computed by circuits of size approximately $T(n)$.

    Mainly, we consider the following two families of circuits:

    \begin{itemize}
        \item We define \textbf{formulas} as boolean circuit whose underlying graphs are trees. Equivalently, this means that the out-degree of each of their gates is one (except for their top gates, whose out-degree is still 0).
        
        \item We define \textbf{monotone circuits} as boolean circuits that do not use negated variables. Equivalently, this means that they compute \textit{monotone functions}, that being functions such that given two inputs $x = (x_1, \ldots, x_n)$ and $y = (y_1, \ldots, y_n)$ we have that:
        \[\forall i \in [1,n] \;\; x_i \leq y_i \implies f(x) \leq f(y)\]
    \end{itemize}

    \textbf{Facts (TO BE PROVEN):}

    \begin{itemize}
        \item Every boolean function $\func{f}{\{0,1\}^n}{\{0,1\}}$ can be computed by a boolean circuit of depth $n$ and size $O \rbk{\frac{2^n}{n}}$.

        \item Every function $f$ computed by a circuit of depth $d$ can always be computed by a formula whose size is at most $2^d$ and depth at most $d$
    \end{itemize}


    \section{Karchmer-Wigderson Games}

    \begin{frameddefn}{Karchmer-Widgerson Game}
        Given the function $\func{f}{\{0,1\}^n}{\{0,1\}}$, we define the \textit{Karchmer-Wigderson game of $f$}, denoted as $\mathsf{KW}(f)$, as the following communication problem: Alice and Bob respectively get the inputs $x = (x_1, \ldots, x_n)$ and $y = (y_1, \ldots, y_n)$, where $f(x) = 0$ and $f(y) = 1$, and their goal is to determine an index $i \in [n]$ such that $x_i \neq y_i$.
    \end{frameddefn}

    \begin{frameddefn}{Monotone Karchmer-Widgerson Game}
        Given the monotone function $\func{f}{\{0,1\}^n}{\{0,1\}}$, we define the \textit{monotone Karchmer-Wigderson game of $f$}, denoted as $\mathsf{mKW}(f)$, as the following communication problem: Alice and Bob respectively get the inputs $x = (x_1, \ldots, x_n)$ and $y = (y_1, \ldots, y_n)$, where $f(x) = 0$ and $f(y) = 1$, and their goal is to determine an index $i \in [n]$ such that $x_i < y_i$.
    \end{frameddefn}
    
    \begin{framedlem}{}
        Given a function $\func{f}{\{0,1\}^n}{\{0,1\}}$, if there exists a circuit of depth $d$ that computes $f$, then there exists a protocol of length $d$ that solves $\mathsf{KW}(f)$ has length $d$.

        Moreover, if $f$ is monotone, the circuit is monotone and the protocol solves $\mathsf{mKW}(f)$
    \end{framedlem}

    \proofenv[Proof]{

        Starting from the top gate, consider the function $f$ computed by the current node:
        \begin{itemize}
            \item If $f = g \land h$, meaning that the top gate is an \textsf{AND} gate, we have that:
            \[f(x) = g(x) \land h(x) = 0 \implies g(x) = 0 \lor h(x) = 0\]
            \[f(y) = g(y) \land h(y) = 1 \implies g(x) = 1 \land h(x) = 1\]
        
            Then, Alice can announce to Bob whether $g(x) = 0$ or $h(x) = 0$. Once the message has been sent, they can both continue the communication by proceeding with the node computing the function that Alice evaluated to $0$ (either $g$ or $h$).

            \item If $f = g \lor h$, meaning that the top gate is an \textsf{OR} gate, we have that:
            \[f(x) = g(x) \lor h(x) = 0 \implies g(x) = 0 \land h(x) = 0\]
            \[f(y) = g(y) \lor h(y) = 1 \implies g(x) = 1 \lor h(x) = 1\]
        
            Then, Bob can announce to Alice whether $g(x) = 1$ or $h(x) = 1$. Once the message has been sent, they can both continue the communication by proceeding with the node computing the function that Bob evaluated to $1$ (either $g$ or $h$).
        \end{itemize}

        Once the procedure receives the $i$-th input variable, we have that:

        \begin{itemize}
            \item If $f(x) = x_i$ and $f(y) = y_i$, Alice and Bob determine that $i$ is an index such that $0 = f(x) = x_i \neq y_i = f(y) = 1$, implying that $x_i = 0$ and $y_i = 1$.
                
            \item If $f(x) = \overline{x_i}$ and $f(y) = \overline{y_i}$, Alice and Bob determine that $i$ is an index such that $0 = f(x) = \overline{x_i} \neq \overline{y_i} = f(y) = 1$, implying that $x_i = 1$ and $y_i = 0$.
        \end{itemize}

        This implies that the protocol solves $\mathsf{KW}(f)$. In particular, if the circuit is \textit{monotone}, the determined index $i$ such that $x_i \neq y_i$, the only possibility is $x_i = 0$ and $y_i = 1$ due to the absence of input variable negations, meaning that the protocol solves $\mathsf{mKW}(f)$.

        By definition of the given protocol, every \textsf{AND} gate corresponds to a node of the protocol where Alice speaks, every \textsf{OR} gate corresponds to a node of the protocol where Bob speaks and every input variable corresponds to a leaf of the protocol, implying that a circuit of depth $d$ yields a protocol of length $d$.
    }

    \begin{framedlem}{}
        Given a function $\func{f}{\{0,1\}^n}{\{0,1\}}$, if there exists a protocol of length $d$ that solves $\mathsf{KW}(f)$, there exists a circuit of depth $d$ that computes $f$.

        Moreover, if $f$ is monotone, the circuit is monotone and the protocol solves $\mathsf{mKW}(f)$
    \end{framedlem}

    \proofenv[Proof]{

        By induction on the length $d$, we prove that for any non-empty sets $A \subseteq f^{-1}(0)$ and $B \subseteq f^{-1}(1)$ it holds that if there is a protocol such that whenever $x \in A$ is given to Alice, $y \in B$ is given to Bob and they can exchange $d$ bits to find and index $i \in [n]$ such that $x_i \neq y_i$, then there is a circuit of depth $d$ computing the boolean function $g$ such that $g(A) = 0$ and $g(B) = 1$.

        When $d = 0$, the protocol must have a fixed output $i$, directly implying that $x_i \neq y_i$ for all $x \in A$ and $y \in B$. Thus, $g$ can be set as the $i$-th variable or its negation.

        Suppose now that $d > 0$. Let $A_0$ and $A_1$ be the sets of inputs in $A$ that respectively lead her to send a 0 and a 1 as the first message. Likewise, we define $B_0$ and $B_1$. These two pair of sets respectively partition $A$ and $B$.
        
        Suppose now that Alice speaks first. If $A_0 = \varnothing$ or $A_1 = \varnothing$, we can ignore the first message and thus conclude the proof. Instead, if $A_0 \neq \varnothing$ and $A_1 \neq \varnothing$, we consider the two subtrees of the children of the first message in the protocol tree.
        
        Since these two subtrees describe protocols of length $d-1$, by induction we know that they respectively compute two boolean functions $g_0$ and $g_1$ with two corresponding boolean circuits of length $d-1$, where $g_0(A_0) = g_1(A_1) = 0$ and $g_0(B) = g_1(B) = 1$.

        Consider now the circuit that takes the \textsf{AND} of these two circuits inductively obtained and let $g$ be the function computed by this circuit, meaning that $g = g_0 \land g_1$.
        
        For all $y \in B$, we have that $g(y) = g_0(y) \land g_1(y) = 1$. Instead, for all $x \in A$ we have that either $x \in A_0$ or $x \in A_1$ (since $A_0$ and $A_1$ partition $A$). However, in either case it holds that $g(x) = g_0(x) \land g_1(x) = 0$. Thus, we conclude that $g(A) = 0$ and $g(B) = 1$ either if Alice's input leads to a 0 or a 1.

        Suppose now that Bob speaks first. If $B_0 = \varnothing$ or $B_1 = \varnothing$, we can ignore the first message and thus conclude the proof. Instead, if $B_0 \neq \varnothing$ and $B_1 \neq \varnothing$, we consider the two subtrees of the children of the first message in the protocol tree.
        
        Since these two subtrees describe protocols of length $d-1$, by induction we know that they respectively compute two boolean functions $h_0$ and $h_1$ with two corresponding boolean circuits of length $d-1$, where $h_0(B_0) = h_1(B_1) = 1$ and $h_0(A) = h_1(A) = 0$.

        Consider now the circuit that takes the \textsf{OR} of these two circuits inductively obtained and let $g$ be the function computed by this circuit, meaning that $g = h_0 \land h_1$.
        
        For all $x \in A$, we have that $g(x) = h_0(x) \lor h_1(x) = 0$. Instead, for all $y \in A$ we have that either $y \in B_0$ or $y \in B_1$ (since $B_0$ and $B_1$ partition $A$). However, in either case it holds that $g(x) = h_0(x) \lor h_1(x) = 1$. Thus, we conclude that $g(A) = 0$ and $g(B) = 1$ either if Bob's input leads to a 0 or a 1.

        Since in each case we conclude that $g(A) = 0$ and $g(B) = 1$, the statement holds for all possible lengths $d \in \N$.
        
        At last, we consider the case when $A = f^{-1}(0)$ and $B = f^{-1}(1)$. Therefore, there exists a circuit that computes a function $g$ such that $g(f^{-1}(0)) = 0$ and $g(f^{-1}(1)) = 1$, implying that $g = f$ and thus that there exists a circuit computing $f$ with depth $d$.

        Moreover, if the protocol solves $\mathsf{mKW}(f)$, the function $f$ must be monotone, implying that the circuit is also monotone.
    }

    \begin{framedthm}{}
        Given a function $\func{f}{\{0,1\}^n}{\{0,1\}}$, there exists a circuit of depth $d$ that computes $f$ if and only if there exists a protocol of length $d$ that solves $\mathsf{KW}(f)$ has length $d$.

        Moreover, if $f$ is monotone, the circuit is monotone and the protocol solves $\mathsf{mKW}(f)$

        (\textit{Follows from the previous lemmas})
    \end{framedthm}

\end{document}
